#version 460
#extension GL_NV_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1, rgba32ui) uniform uimage2D image;
layout(set = 0, binding = 2) uniform sampler2D gbufferPosSampler;

layout(location = 0) rayPayloadNV uint hitValue;


#include "light.glsl"

void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);


    vec3 origin = texture(gbufferPosSampler, inUV).xyz;

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    
    uvec4 bitField = uvec4(0U);
    //hitValue = 0U;
    for(int i = 0; i < dirLights.length(); i++)
    {
        DirectionalLight currentLight = dirLights[i];
        vec3 direction = -normalize(currentLight.direction);

        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );

        // todo only 32 light sources supported
        bitField.x = bitfieldInsert(bitField.x, hitValue, i, 1);
    }

    for(int i = 0; i < pointLights.length(); i++)
    {
        PointLight currentLight = pointLights[i];
        vec3 direction = normalize(currentLight.position - origin);

        tmax = length(currentLight.position - origin);
        //TODO tmax should also not be greater than the "radius of the influence sphere" of the point light

        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );

        // todo only 32 light sources supported
        bitField.y = bitfieldInsert(bitField.y, hitValue, i, 1);
    }

    for(int i = 0; i < spotLights.length(); i++)
    {
        SpotLight currentLight = spotLights[i];
        vec3 direction = normalize(currentLight.position - origin);

        if(dot(direction, normalize(currentLight.direction)) > currentLight.outerCutoff)
            continue;

        tmax = length(currentLight.position - origin);
        //TODO tmax should also not be greater than the "radius of the influence sphere" of the point light

        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );

        // todo only 32 light sources supported
        bitField.z = bitfieldInsert(bitField.z, hitValue, i, 1);
    }

    imageStore(image, ivec2(gl_LaunchIDNV.xy), bitField);
}