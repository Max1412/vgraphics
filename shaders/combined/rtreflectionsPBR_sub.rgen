#version 460
#extension GL_NV_ray_tracing : require
#extension GL_KHR_shader_subgroup_basic : require

const float PI = 3.1415926535;

layout(location = 0) rayPayloadNV vec3 hitValue;

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform sampler2D gbufferPosSampler;
layout(set = 0, binding = 2) uniform sampler2D gbufferNormalSampler;
layout(set = 0, binding = 12) uniform sampler2D gbufferUVSampler;

layout(constant_id = 0) const int NUM_TEXTURES = 64;
layout(set = 0, binding = 11) uniform sampler2D allTextures[NUM_TEXTURES];

layout(set = 0, binding = 3, rgba32ui) uniform uimage2D randTex;

#include "random.glsl"
#include "structs.glsl"

layout(set = 0, binding = 4, std430) readonly buffer rtPerFrameBuffer
{
    RTperFrameInfo2 perFrameInfo;
};

layout(set = 0, binding = 9) readonly buffer materialBuffer
{
    MaterialInfoPBR materials[];
};

layout(std430, set = 0, binding = 10) readonly buffer indirectDrawBuffer
{
    PerMeshInfoPBR perMesh[];
} perMeshInfos;


layout(set = 0, binding = 5, rgba32f) uniform image2D reflectionImage;

// radical inverse function
float RadicalInverse(uint bits) 
{
    return float(bitfieldReverse(bits)) * 2.3283064365386963e-10; // / 0x100000000
}

// generate hammersley sequence using RIF
vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse(i));
}  

vec2 ggx_importance_sample(const in vec2 random_sample, const in float roughness)
{
    float phi    = random_sample.y * 2.f * 3.14156235659f;
    float rough2 = roughness * roughness;
    float theta  = atan(sqrt(rough2 * random_sample.x / (1 - random_sample.x)));
    return vec2(phi, theta);
}

vec3 ggx_importance_hemisphere(const in vec2 importance_sample)
{
    float phi      = importance_sample.x;
    float cosTheta = cos(importance_sample.y);
    float sinTheta = sin(importance_sample.y);
    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

#include "samplePointGen.glsl"
#include "pbrLight.glsl"

void main()
{
    imageStore(reflectionImage, ivec2(gl_LaunchIDNV.xy), vec4(gl_NumSubgroups, gl_SubgroupID, gl_SubgroupSize, gl_SubgroupInvocationID));
    subgroupBarrier();
    //TODO get mesh ID (from gbuffer) to get material ID
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    randomInit(ivec2(gl_LaunchIDNV.xy));
    rand();
    randomFinish(ivec2(gl_LaunchIDNV.xy));
    if(((gl_LaunchIDNV.x + (gl_LaunchIDNV.y % 2)) % 2) == 0)
    {
        imageStore(reflectionImage, ivec2(gl_LaunchIDNV.xy), vec4(0.0f));
        return;
    }
    // if(!(gl_LaunchIDNV.x % 4 == 0 && gl_LaunchIDNV.y % 4 == 0))
    // {
    //     imageStore(reflectionImage, ivec2(gl_LaunchIDNV.xy), vec4(0.0f));
    //     return;
    // }

    vec4 originAndID = texture(gbufferPosSampler, inUV);
    vec3 normal = normalize(texture(gbufferNormalSampler, inUV).xyz);
    vec4 uvLOD = texture(gbufferUVSampler, inUV);

    vec3 origin = originAndID.xyz;
    int MeshID = int(originAndID.w);

    PerMeshInfoPBR currentMesh = perMeshInfos.perMesh[MeshID];
    MaterialInfoPBR currentMaterial = materials[currentMesh.assimpMaterialIndex];
    //if(currentMaterial.N < 1) return; 

    vec3 viewVector = normalize(origin - perFrameInfo.cameraPosWorld);

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;

    vec3 albedo = vec3(0.0f);
    if(currentMesh.texIndexBaseColor != -1)
        albedo = textureLod(allTextures[currentMesh.texIndexBaseColor], uvLOD.xy, uvLOD.w).xyz;
    else
        albedo = currentMaterial.baseColor;
    albedo = pow(albedo, vec3(2.2));

    vec3 metallicRoughness = vec3(0.0f);
    if(currentMesh.texIndexMetallicRoughness != -1)
        metallicRoughness = textureLod(allTextures[currentMesh.texIndexMetallicRoughness], uvLOD.xy, uvLOD.w).xyz;
    else
    {
        #ifdef FBX
        metallicRoughness = vec3(0.0f, currentMaterial.roughness, currentMaterial.metalness); // what is z? // FBX
        #else
        metallicRoughness = vec3(currentMaterial.metalness, currentMaterial.roughness, 0.0f); // what is z? // GLTF
        #endif
    }

    #ifdef FBX
    float metallic = metallicRoughness.z; // FBX
    #else
    float metallic = metallicRoughness.x; // GLTF
    #endif
    float roughness = metallicRoughness.y + 0.01;

    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
    
    vec3 reflectionValue = vec3(0.0f);
    vec3 weightSum = vec3(0.0f);

    vec3 reflectedViewVector = reflect(viewVector, normal);
    for(int i = 0; i < perFrameInfo.RTReflectionSampleCount; i++)
    {
        vec3 direction = rotateToNormal(ggx_importance_hemisphere(ggx_importance_sample(vec2(rand(), rand()), roughness)), reflectedViewVector);
        while(dot(direction, normal) < 0.0f) // re-roll if direction is not in hemisphere
        {
            direction = rotateToNormal(ggx_importance_hemisphere(ggx_importance_sample(vec2(rand(), rand()), roughness)), normal);
        }

        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );

        vec3 fresnel = fresnelSchlickRoughness(max(dot(direction, normal), 0.0), F0, roughness);

        weightSum += fresnel;
        reflectionValue += fresnel * hitValue; //TODO divide by pdf maybe? how? pi?
    }
    //if(length(weightSum) > 0.0001f) // this can produce NaNs otherwise
        reflectionValue /= float(perFrameInfo.RTReflectionSampleCount); //weightSum;

    float InvSampleCount = 1.0f / (perFrameInfo.frameSampleCount + 1.0f);
    vec3 oldValue = imageLoad(reflectionImage, ivec2(gl_LaunchIDNV.xy)).xyz;
    reflectionValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * reflectionValue;
    imageStore(reflectionImage, ivec2(gl_LaunchIDNV.xy), vec4(reflectionValue, 0.0));

    //randomFinish(ivec2(gl_LaunchIDNV.xy));
}