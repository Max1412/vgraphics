#version 460
#extension GL_NV_ray_tracing : require

layout(location = 0) rayPayloadNV uint hitValue;

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform sampler2D gbufferPosSampler;
layout(set = 0, binding = 2) uniform sampler2D gbufferNormalSampler;
layout(set = 0, binding = 3, rgba32ui) uniform uimage2D randTex;

struct RTperFrameInfo
{
    int frameSampleCount;
};

layout(set = 0, binding = 4) readonly buffer rtPerFrameBuffer
{
    RTperFrameInfo perFrameInfo;
};

layout(set = 1, binding = 0, r32f) uniform image2D rtaoImage;


#include "light.glsl"
#include "random.glsl"

const float PI = 3.1415926535;

float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

float noise(vec3 p){
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);

    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = perm(b.xyxy);
    vec4 k2 = perm(k1.xyxy + b.zzww);

    vec4 c = k2 + a.zzzz;
    vec4 k3 = perm(c);
    vec4 k4 = perm(c + 1.0);

    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));

    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

    return o4.y * d.y + o4.x * (1.0 - d.y);
}

vec3 generatePointOnSphericalLight(in vec3 position, in float radius)
{
    float theta = rand() * 2.0f * PI;
    float u = (rand() * 2.0f) - 1.0f;
    float x = sqrt(1-(u*u)) * cos(theta);
    float y = sqrt(1-(u*u)) * sin(theta);
    float z = u;
    return position + (radius * vec3(x, y, z));
}

vec3 generatePointOnDiskLight(in vec3 position, in float radius, in vec3 normal)
{
    float r = rand();
    float theta = rand() * 2.0f * PI;
    float x = sqrt(r) * cos(theta);
    float y = sqrt(r) * sin(theta);

    vec3 up = vec3(0, 1, 0);

    // check if up == normal
    if(dot(normal, up) == 1.0f) up = vec3(1, 0, 0);

    vec3 a = cross(normal, up);
    vec3 b = cross(a, normal);

    return position + radius * a * x + radius * b * y;
}

vec3 sampleUniformHemisphere(float u, float v) { //u, v are random numbers
	float sinTheta = sqrt(2.0f * u - u * u);  //sin(arccos(x)) = sqrt(1-x^2)
	float phi = 2.0f * PI * v;

	float x = sinTheta * cos(phi);
	float y = sinTheta * sin(phi);	

	// Project point up to the unit sphere
    float z = sqrt(max(0.f, 1.f - x * x - y * y));
    return vec3(x, y, z);
}

vec3 rotateToNormal(in vec3 dir, in vec3 normal) {
	/*vec3 tangent = normalize(abs(normal.x) > abs(normal.y) ? vec3(normal.z, 0.f, -normal.x) : vec3(0.f, -normal.z, normal.y));
	vec3 bitangent = cross(normal, tangent);
	mat3 rotToNormal = mat3(tangent, bitangent, normal);

	return rotToNormal * dir;*/
	vec3 pseudo_perpendicular = (abs(normal.x) <= 0.6f) ? vec3(1, 0, 0) : vec3(0, 1, 0);
    vec3 u = normalize(cross(normal, pseudo_perpendicular));
    vec3 v = normalize(cross(normal, u));
    vec3 w = normal;

    return mat3(u,v,w) * dir;
}

vec3 sampleRotatedHemisphere(in vec3 normal)
{
    vec3 hemiPoint = sampleUniformHemisphere(rand(), rand());
    return rotateToNormal(hemiPoint, normal);
}

const int NUM_RTAO_SAMPLES = 8;
const float RTAO_RADIUS = 100.0f;

void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    randomInit(ivec2(gl_LaunchIDNV.xy));

    vec3 origin = texture(gbufferPosSampler, inUV).xyz;
    vec3 normal = normalize(texture(gbufferNormalSampler, inUV).xyz);

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.01;
    float tmax = 100000.0;
    
    float InvSampleCount = 1.0f / (perFrameInfo.frameSampleCount + 1.0f);

    float rtAOValue = 0.0f;

    for(int i = 0; i < NUM_RTAO_SAMPLES; i++)
    {
        vec3 direction = sampleRotatedHemisphere(normal);
        tmax = RTAO_RADIUS;
        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );
        rtAOValue += hitValue;
    }
    rtAOValue /= float(NUM_RTAO_SAMPLES);


    float oldValue = imageLoad(rtaoImage, ivec2(gl_LaunchIDNV.xy)).x;
    rtAOValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * rtAOValue;
    imageStore(rtaoImage, ivec2(gl_LaunchIDNV.xy), vec4(rtAOValue));

    randomFinish(ivec2(gl_LaunchIDNV.xy));
}