#version 460
#extension GL_NV_ray_tracing : require

layout(location = 0) rayPayloadNV uint hitValue;

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform sampler2D gbufferPosSampler;
layout(set = 0, binding = 2) uniform sampler2D gbufferNormalSampler;
layout(set = 0, binding = 3, rgba32ui) uniform uimage2D randTex;

struct RTperFrameInfo
{
    int frameSampleCount;
};

layout(set = 0, binding = 4) readonly buffer rtPerFrameBuffer
{
    RTperFrameInfo perFrameInfo;
};

layout(set = 1, binding = 0, r32f) uniform image2D rtaoImage;


#include "light.glsl"
#include "random.glsl"
#include "samplePointGen.glsl"

const int NUM_RTAO_SAMPLES = 8;
const float RTAO_RADIUS = 100.0f;

void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    randomInit(ivec2(gl_LaunchIDNV.xy));

    vec3 origin = texture(gbufferPosSampler, inUV).xyz;
    vec3 normal = normalize(texture(gbufferNormalSampler, inUV).xyz);

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.01;
    float tmax = 100000.0;
    
    float InvSampleCount = 1.0f / (perFrameInfo.frameSampleCount + 1.0f);

    float rtAOValue = 0.0f;

    for(int i = 0; i < NUM_RTAO_SAMPLES; i++)
    {
        vec3 direction = sampleRotatedHemisphere(normal);
        tmax = RTAO_RADIUS;
        traceNV(topLevelAS, rayFlags, cullMask,
            0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
            origin, tmin, direction, tmax,
            0 /*payload*/ // X here is location = X of the payload
        );
        rtAOValue += hitValue;
    }
    rtAOValue /= float(NUM_RTAO_SAMPLES);


    float oldValue = imageLoad(rtaoImage, ivec2(gl_LaunchIDNV.xy)).x;
    rtAOValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * rtAOValue;
    imageStore(rtaoImage, ivec2(gl_LaunchIDNV.xy), vec4(rtAOValue));

    randomFinish(ivec2(gl_LaunchIDNV.xy));
}