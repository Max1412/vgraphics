#version 460
#extension GL_NV_ray_tracing : require
const float PI = 3.1415926535;

layout(location = 0) rayPayloadNV vec3 hitValue;

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform sampler2D gbufferPosSampler;
layout(set = 0, binding = 2) uniform sampler2D gbufferNormalSampler;
layout(set = 0, binding = 12) uniform sampler2D gbufferUVSampler;

layout(constant_id = 0) const int NUM_TEXTURES = 64;
layout(set = 0, binding = 11) uniform sampler2D allTextures[NUM_TEXTURES];

layout(set = 0, binding = 3, rgba32ui) uniform uimage2D randTex;

#include "random.glsl"
#include "structs.glsl"

layout(set = 0, binding = 4, std430) readonly buffer rtPerFrameBuffer
{
    RTperFrameInfo2 perFrameInfo;
};

struct MaterialInfoPBR
{
	vec3 baseColor;
	float roughness;
	vec3 f0;
	float metalness;
};

layout(set = 0, binding = 9) readonly buffer materialBuffer
{
    MaterialInfoPBR materials[];
};

struct PerMeshInfoPBR
{
    // standard
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
    // additional
	int texIndexBaseColor;
	int texIndexMetallicRoughness;
    int assimpMaterialIndex;
};

layout(std430, set = 0, binding = 10) readonly buffer indirectDrawBuffer
{
    PerMeshInfoPBR perMesh[];
} perMeshInfos;


layout(set = 0, binding = 5, rgba32f) uniform image2D reflectionImage;

// radical inverse function
float RadicalInverse(uint bits) 
{
    return float(bitfieldReverse(bits)) * 2.3283064365386963e-10; // / 0x100000000
}

// generate hammersley sequence using RIF
vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse(i));
}  

vec2 ggx_importance_sample(const in vec2 random_sample, const in float roughness)
{
    float phi    = random_sample.y * 2.f * 3.14156235659f;
    float rough2 = roughness * roughness;
    float theta  = atan(sqrt(rough2 * random_sample.x / (1 - random_sample.x)));
    return vec2(phi, theta);
}

vec3 ggx_importance_hemisphere(const in vec2 importance_sample)
{
    float phi      = importance_sample.x;
    float cosTheta = cos(importance_sample.y);
    float sinTheta = sin(importance_sample.y);
    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

#include "samplePointGen.glsl"

void main()
{
    //TODO get mesh ID (from gbuffer) to get material ID

    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    randomInit(ivec2(gl_LaunchIDNV.xy));


    vec4 originAndID = texture(gbufferPosSampler, inUV);
    vec3 normal = normalize(texture(gbufferNormalSampler, inUV).xyz);
    vec4 uvLOD = texture(gbufferUVSampler, inUV);

    vec3 origin = originAndID.xyz;
    int MeshID = int(originAndID.w);

    PerMeshInfoPBR currentMesh = perMeshInfos.perMesh[MeshID];
    MaterialInfoPBR currentMaterial = materials[currentMesh.assimpMaterialIndex];
    //if(currentMaterial.N < 1) return; 

    vec3 viewVector = normalize(origin - perFrameInfo.cameraPosWorld);

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;

    
    float roughness = 0.0f;
    if(currentMesh.texIndexMetallicRoughness != -1)
        roughness = textureLod(allTextures[currentMesh.texIndexMetallicRoughness], uvLOD.xy, uvLOD.w).y;
    else
        roughness = currentMaterial.roughness;

    vec3 direction = rotateToNormal(ggx_importance_hemisphere(ggx_importance_sample(vec2(rand(), rand()), roughness)), normal);

    traceNV(topLevelAS, rayFlags, cullMask,
        0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
        origin, tmin, direction, tmax,
        0 /*payload*/ // X here is location = X of the payload
    );
    
    vec3 reflectionValue = hitValue;

    float InvSampleCount = 1.0f / (perFrameInfo.frameSampleCount + 1.0f);
    vec3 oldValue = imageLoad(reflectionImage, ivec2(gl_LaunchIDNV.xy)).xyz;
    reflectionValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * reflectionValue;
    imageStore(reflectionImage, ivec2(gl_LaunchIDNV.xy), vec4(reflectionValue, 0.0));

    randomFinish(ivec2(gl_LaunchIDNV.xy));
}