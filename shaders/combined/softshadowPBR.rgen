#version 460
#extension GL_NV_ray_tracing : require
const float PI = 3.1415926535;

layout(location = 0) rayPayloadNV uint hitValue;

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform sampler2D gbufferPosSampler;
layout(set = 0, binding = 2, rgba32ui) uniform uimage2D randTex;

#include "structs.glsl"

layout(set = 0, binding = 3) readonly buffer rtPerFrameBuffer
{
    RTperFrameInfo2 perFrameInfo;
};

layout(set = 2, binding = 0, r32f) uniform image2DArray softShadowDirectionalImage;
layout(set = 2, binding = 1, r32f) uniform image2DArray softShadowPointImage;
layout(set = 2, binding = 2, r32f) uniform image2DArray softShadowSpotImage;

#include "random.glsl"
#include "samplePointGen.glsl"
#include "pbrLight.glsl"
#include "halton.glsl"

float randHalton(inout HaltonState hState)
{
    return fract(haltonNext(hState));// + rand());
}

vec3 generatePointOnSphericalLightHalton(in vec3 position, in float radius, inout HaltonState hState)
{
    float rand1 = randHalton(hState);
    float rand2 = randHalton(hState);
    float theta = rand1 * 2.0f * PI;
    float u = (rand2 * 2.0f) - 1.0f;
    float x = sqrt(1-(u*u)) * cos(theta);
    float y = sqrt(1-(u*u)) * sin(theta);
    float z = u;
    return position + (radius * vec3(x, y, z));
}


void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    randomInit(ivec2(gl_LaunchIDNV.xy));
    rand();
    randomFinish(ivec2(gl_LaunchIDNV.xy));

    vec3 origin = texture(gbufferPosSampler, inUV).xyz;

    //uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsTerminateOnFirstHitNV;
    uint rayFlags = gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 100000.0;
    
    float InvSampleCount = 1.0f / (perFrameInfo.frameSampleCount + 1.0f);

    // HaltonState hState;
    // haltonInit(hState, int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), 1, 2, perFrameInfo.frameSampleCount, 1);

    for(int i = 0; i < dirLights.length(); i++)
    {
        float dirShadowValue = 0.0f;

        PBRDirectionalLight currentLight = dirLights[i];

        for(int j = 0; j < currentLight.numShadowSamples; j++)
        {            
            //todo jitter direction better. this converges really slowly
            vec3 direction = normalize(-(currentLight.direction + 0.2 * vec3(rand(), rand(), rand())));

            hitValue = 0U;

            traceNV(topLevelAS, rayFlags, cullMask,
                0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
                origin, tmin, direction, tmax,
                0 /*payload*/ // X here is location = X of the payload
            );

            dirShadowValue += hitValue;
        }
        dirShadowValue /= float(currentLight.numShadowSamples);

        // save incrementally
        float oldValue = imageLoad(softShadowDirectionalImage, ivec3(gl_LaunchIDNV.xy, i)).x;
        dirShadowValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * dirShadowValue;
        imageStore(softShadowDirectionalImage, ivec3(gl_LaunchIDNV.xy, i), vec4(dirShadowValue));

    }

    for(int i = 0; i < pointLights.length(); i++)
    {
        float pointShadowValue = 0.0f;

        PBRPointLight currentLight = pointLights[i];

        //TODO tmax should also not be greater than the "radius of the influence sphere" of the point light
        for(int j = 0; j < currentLight.numShadowSamples; j++)
        {            
            //vec3 pointOnLight = generatePointOnSphericalLight2(currentLight.position, currentLight.radius);//, hState);
            //vec3 pointOnLight = generatePointOnSphericalLightHalton(currentLight.position, currentLight.radius, hState);

            tmax = length(currentLight.position - origin);

            vec3 toLight = normalize(currentLight.position - origin);

            float hyp = sqrt(tmax * tmax + currentLight.radius * currentLight.radius);
            float cosTheta = tmax/hyp;//atan(currentLight.radius, tmax);
            vec3 directionCone = generateConeDirection(cosTheta);
            vec3 direction = rotateToNormal(directionCone, toLight);
            tmax += currentLight.radius;
            direction = normalize(direction);

            // vec3 pointOnLight = generatePointOnSphericalLight(currentLight.position, currentLight.radius);
            // tmax = length(pointOnLight - origin);

            // vec3 direction = normalize(pointOnLight - origin);

            //TODO nicht tracen wenn außerhalb von "einflussradius"!!
            hitValue = 0U;

           traceNV(topLevelAS, rayFlags, cullMask,
                0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
                origin, tmin, direction, tmax,
                0 /*payload*/ // X here is location = X of the payload
            );

            pointShadowValue += hitValue;
        }
        pointShadowValue /= float(currentLight.numShadowSamples);

        // save incrementally
        float oldValue = imageLoad(softShadowPointImage, ivec3(gl_LaunchIDNV.xy, i)).x;
        pointShadowValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * pointShadowValue;
        imageStore(softShadowPointImage, ivec3(gl_LaunchIDNV.xy, i), vec4(pointShadowValue));

    }

    for(int i = 0; i < spotLights.length(); i++)
    {
        float spotShadowValue = 0.0f;

        PBRSpotLight currentLight = spotLights[i];

        for(int j = 0; j < currentLight.numShadowSamples; j++)
        {            
            vec3 pointOnLight = generatePointOnDiskLight(currentLight.position, currentLight.radius, normalize(currentLight.direction));
            tmax = length(pointOnLight - origin);

            vec3 direction = normalize(pointOnLight - origin);

            //TODO nicht tracen wenn außerhalb von outercutoff!!
            hitValue = 0U;

            traceNV(topLevelAS, rayFlags, cullMask,
                0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/,
                origin, tmin, direction, tmax,
                0 /*payload*/ // X here is location = X of the payload
            );

            spotShadowValue += hitValue;
        }
        spotShadowValue /= float(currentLight.numShadowSamples);

        // save incrementally
        float oldValue = imageLoad(softShadowSpotImage, ivec3(gl_LaunchIDNV.xy, i)).x;
        spotShadowValue = (perFrameInfo.frameSampleCount * InvSampleCount) * oldValue + InvSampleCount * spotShadowValue;
        imageStore(softShadowSpotImage, ivec3(gl_LaunchIDNV.xy, i), vec4(spotShadowValue));
    }



    //randomFinish(ivec2(gl_LaunchIDNV.xy));
}